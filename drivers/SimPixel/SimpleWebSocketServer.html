<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>spixel.drivers.SimPixel.SimpleWebSocketServer API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spixel.drivers.SimPixel.SimpleWebSocketServer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># flake8: noqa
import sys
VER = sys.version_info[0]
if VER &gt;= 3:
    import socketserver
    from http.server import BaseHTTPRequestHandler
    from io import StringIO, BytesIO
else:
    import SocketServer
    from BaseHTTPServer import BaseHTTPRequestHandler
    from StringIO import StringIO

import hashlib
import base64
import socket
import struct
import ssl
import errno
import codecs
from collections import deque
from select import select

__all__ = [&#39;WebSocket&#39;,
           &#39;SimpleWebSocketServer&#39;]


def _check_unicode(val):
    if VER &gt;= 3:
        return isinstance(val, str)
    else:
        return isinstance(val, unicode)


class HTTPRequest(BaseHTTPRequestHandler):

    def __init__(self, request_text):
        if VER &gt;= 3:
            self.rfile = BytesIO(request_text)
        else:
            self.rfile = StringIO(request_text)
        self.raw_requestline = self.rfile.readline()
        self.error_code = self.error_message = None
        self.parse_request()


_VALID_STATUS_CODES = [1000, 1001, 1002, 1003, 1007, 1008,
                       1009, 1010, 1011, 3000, 3999, 4000, 4999]


HANDSHAKE_STR = (
    &#34;HTTP/1.1 101 Switching Protocols\r\n&#34;
    &#34;Upgrade: WebSocket\r\n&#34;
    &#34;Connection: Upgrade\r\n&#34;
    &#34;Sec-WebSocket-Accept: %(acceptstr)s\r\n\r\n&#34;
)

GUID_STR = &#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;

STREAM = 0x0
TEXT = 0x1
BINARY = 0x2
CLOSE = 0x8
PING = 0x9
PONG = 0xA

HEADERB1 = 1
HEADERB2 = 3
LENGTHSHORT = 4
LENGTHLONG = 5
MASK = 6
PAYLOAD = 7

MAXHEADER = 65536
MAXPAYLOAD = 33554432


class WebSocket(object):

    def __init__(self, server, sock, address):
        self.server = server
        self.client = sock
        self.address = address

        self.handshaked = False
        self.headerbuffer = bytearray()
        self.headertoread = 2048

        self.fin = 0
        self.data = bytearray()
        self.opcode = 0
        self.hasmask = 0
        self.maskarray = None
        self.length = 0
        self.lengtharray = None
        self.index = 0
        self.request = None
        self.usingssl = False

        self.frag_start = False
        self.frag_type = BINARY
        self.frag_buffer = None
        self.frag_decoder = codecs.getincrementaldecoder(
            &#39;utf-8&#39;)(errors=&#39;strict&#39;)
        self.closed = False
        self.sendq = deque()

        self.state = HEADERB1

        # restrict the size of header and payload for security reasons
        self.maxheader = MAXHEADER
        self.maxpayload = MAXPAYLOAD

    def handleMessage(self):
        &#34;&#34;&#34;
            Called when websocket frame is received.
            To access the frame data call self.data.

            If the frame is Text then self.data is a unicode object.
            If the frame is Binary then self.data is a bytearray object.
        &#34;&#34;&#34;
        pass

    def handleConnected(self):
        &#34;&#34;&#34;
            Called when a websocket client connects to the server.
        &#34;&#34;&#34;
        pass

    def handleClose(self):
        &#34;&#34;&#34;
            Called when a websocket server gets a Close frame from a client.
        &#34;&#34;&#34;
        pass

    def _handlePacket(self):
        if self.opcode == CLOSE:
            pass
        elif self.opcode == STREAM:
            pass
        elif self.opcode == TEXT:
            pass
        elif self.opcode == BINARY:
            pass
        elif self.opcode == PONG or self.opcode == PING:
            if len(self.data) &gt; 125:
                raise Exception(&#39;control frame length can not be &gt; 125&#39;)
        else:
            # unknown or reserved opcode so just close
            raise Exception(&#39;unknown opcode&#39;)

        if self.opcode == CLOSE:
            status = 1000
            reason = u&#39;&#39;
            length = len(self.data)

            if length == 0:
                pass
            elif length &gt;= 2:
                status = struct.unpack_from(&#39;!H&#39;, self.data[:2])[0]
                reason = self.data[2:]

                if status not in _VALID_STATUS_CODES:
                    status = 1002

                if len(reason) &gt; 0:
                    try:
                        reason = reason.decode(&#39;utf8&#39;, errors=&#39;strict&#39;)
                    except:
                        status = 1002
            else:
                status = 1002

            self.close(status, reason)
            return

        elif self.fin == 0:
            if self.opcode != STREAM:
                if self.opcode == PING or self.opcode == PONG:
                    raise Exception(&#39;control messages can not be fragmented&#39;)

                self.frag_type = self.opcode
                self.frag_start = True
                self.frag_decoder.reset()

                if self.frag_type == TEXT:
                    self.frag_buffer = []
                    utf_str = self.frag_decoder.decode(self.data, final=False)
                    if utf_str:
                        self.frag_buffer.append(utf_str)
                else:
                    self.frag_buffer = bytearray()
                    self.frag_buffer.extend(self.data)

            else:
                if self.frag_start is False:
                    raise Exception(&#39;fragmentation protocol error&#39;)

                if self.frag_type == TEXT:
                    utf_str = self.frag_decoder.decode(self.data, final=False)
                    if utf_str:
                        self.frag_buffer.append(utf_str)
                else:
                    self.frag_buffer.extend(self.data)

        else:
            if self.opcode == STREAM:
                if self.frag_start is False:
                    raise Exception(&#39;fragmentation protocol error&#39;)

                if self.frag_type == TEXT:
                    utf_str = self.frag_decoder.decode(self.data, final=True)
                    self.frag_buffer.append(utf_str)
                    self.data = u&#39;&#39;.join(self.frag_buffer)
                else:
                    self.frag_buffer.extend(self.data)
                    self.data = self.frag_buffer

                self.handleMessage()

                self.frag_decoder.reset()
                self.frag_type = BINARY
                self.frag_start = False
                self.frag_buffer = None

            elif self.opcode == PING:
                self._sendMessage(False, PONG, self.data)

            elif self.opcode == PONG:
                pass

            else:
                if self.frag_start is True:
                    raise Exception(&#39;fragmentation protocol error&#39;)

                if self.opcode == TEXT:
                    try:
                        self.data = self.data.decode(&#39;utf8&#39;, errors=&#39;strict&#39;)
                    except Exception:
                        raise Exception(&#39;invalid utf-8 payload&#39;)

                self.handleMessage()

    def _handleData(self):
        # do the HTTP header and handshake
        if self.handshaked is False:

            data = self.client.recv(self.headertoread)
            if not data:
                raise Exception(&#39;remote socket closed&#39;)

            else:
                # accumulate
                self.headerbuffer.extend(data)

                if len(self.headerbuffer) &gt;= self.maxheader:
                    raise Exception(&#39;header exceeded allowable size&#39;)

                # indicates end of HTTP header
                if b&#39;\r\n\r\n&#39; in self.headerbuffer:
                    self.request = HTTPRequest(self.headerbuffer)

                    # handshake rfc 6455
                    try:
                        key = self.request.headers[&#39;Sec-WebSocket-Key&#39;]
                        k = key.encode(&#39;ascii&#39;) + GUID_STR.encode(&#39;ascii&#39;)
                        k_s = base64.b64encode(
                            hashlib.sha1(k).digest()).decode(&#39;ascii&#39;)
                        hStr = HANDSHAKE_STR % {&#39;acceptstr&#39;: k_s}
                        self.sendq.append((BINARY, hStr.encode(&#39;ascii&#39;)))
                        self.handshaked = True
                        self.handleConnected()
                    except Exception as e:
                        raise Exception(&#39;handshake failed: %s&#39;, str(e))

        # else do normal data
        else:
            data = self.client.recv(8192)
            if not data:
                raise Exception(&#34;remote socket closed&#34;)

            if VER &gt;= 3:
                for d in data:
                    self._parseMessage(d)
            else:
                for d in data:
                    self._parseMessage(ord(d))

    def close(self, status=1000, reason=u&#39;&#39;):
        &#34;&#34;&#34;
           Send Close frame to the client. The underlying socket is only closed
           when the client acknowledges the Close frame.

           status is the closing identifier.
           reason is the reason for the close.
         &#34;&#34;&#34;
        try:
            if self.closed is False:
                close_msg = bytearray()
                close_msg.extend(struct.pack(&#34;!H&#34;, status))
                if _check_unicode(reason):
                    close_msg.extend(reason.encode(&#39;utf-8&#39;))
                else:
                    close_msg.extend(reason)

                self._sendMessage(False, CLOSE, close_msg)

        finally:
            self.closed = True

    def _sendBuffer(self, buff):
        size = len(buff)
        tosend = size
        already_sent = 0

        while tosend &gt; 0:
            try:
                # i should be able to send a bytearray
                sent = self.client.send(buff[already_sent:])
                if sent == 0:
                    raise RuntimeError(&#39;socket connection broken&#39;)

                already_sent += sent
                tosend -= sent

            except socket.error as e:
                # if we have full buffers then wait for them to drain and try
                # again
                if e.errno in [errno.EAGAIN, errno.EWOULDBLOCK]:
                    return buff[already_sent:]
                else:
                    raise e

        return None

    def sendFragmentStart(self, data):
        &#34;&#34;&#34;
            Send the start of a data fragment stream to a websocket client.
            Subsequent data should be sent using sendFragment().
            A fragment stream is completed when sendFragmentEnd() is called.

            If data is a unicode object then the frame is sent as Text.
            If the data is a bytearray object then the frame is sent as Binary.
        &#34;&#34;&#34;
        opcode = BINARY
        if _check_unicode(data):
            opcode = TEXT
        self._sendMessage(True, opcode, data)

    def sendFragment(self, data):
        &#34;&#34;&#34;
            see sendFragmentStart()

            If data is a unicode object then the frame is sent as Text.
            If the data is a bytearray object then the frame is sent as Binary.
        &#34;&#34;&#34;
        self._sendMessage(True, STREAM, data)

    def sendFragmentEnd(self, data):
        &#34;&#34;&#34;
            see sendFragmentEnd()

            If data is a unicode object then the frame is sent as Text.
            If the data is a bytearray object then the frame is sent as Binary.
        &#34;&#34;&#34;
        self._sendMessage(False, STREAM, data)

    def sendMessage(self, data):
        &#34;&#34;&#34;
            Send websocket data frame to the client.

            If data is a unicode object then the frame is sent as Text.
            If the data is a bytearray object then the frame is sent as Binary.
        &#34;&#34;&#34;
        opcode = BINARY
        if _check_unicode(data):
            opcode = TEXT
        self._sendMessage(False, opcode, data)

    def _sendMessage(self, fin, opcode, data):

        payload = bytearray()

        b1 = 0
        b2 = 0
        if fin is False:
            b1 |= 0x80
        b1 |= opcode

        if _check_unicode(data):
            data = data.encode(&#39;utf-8&#39;)

        length = len(data)
        payload.append(b1)

        if length &lt;= 125:
            b2 |= length
            payload.append(b2)

        elif length &gt;= 126 and length &lt;= 65535:
            b2 |= 126
            payload.append(b2)
            payload.extend(struct.pack(&#34;!H&#34;, length))

        else:
            b2 |= 127
            payload.append(b2)
            payload.extend(struct.pack(&#34;!Q&#34;, length))

        if length &gt; 0:
            payload.extend(data)

        self.sendq.append((opcode, payload))

    def _parseMessage(self, byte):
        # read in the header
        if self.state == HEADERB1:

            self.fin = byte &amp; 0x80
            self.opcode = byte &amp; 0x0F
            self.state = HEADERB2

            self.index = 0
            self.length = 0
            self.lengtharray = bytearray()
            self.data = bytearray()

            rsv = byte &amp; 0x70
            if rsv != 0:
                raise Exception(&#39;RSV bit must be 0&#39;)

        elif self.state == HEADERB2:
            mask = byte &amp; 0x80
            length = byte &amp; 0x7F

            if self.opcode == PING and length &gt; 125:
                raise Exception(&#39;ping packet is too large&#39;)

            if mask == 128:
                self.hasmask = True
            else:
                self.hasmask = False

            if length &lt;= 125:
                self.length = length

                # if we have a mask we must read it
                if self.hasmask is True:
                    self.maskarray = bytearray()
                    self.state = MASK
                else:
                    # if there is no mask and no payload we are done
                    if self.length &lt;= 0:
                        try:
                            self._handlePacket()
                        finally:
                            self.state = self.HEADERB1
                            self.data = bytearray()

                    # we have no mask and some payload
                    else:
                        self.data = bytearray()
                        self.state = PAYLOAD

            elif length == 126:
                self.lengtharray = bytearray()
                self.state = LENGTHSHORT

            elif length == 127:
                self.lengtharray = bytearray()
                self.state = LENGTHLONG

        elif self.state == LENGTHSHORT:
            self.lengtharray.append(byte)

            if len(self.lengtharray) &gt; 2:
                raise Exception(&#39;short length exceeded allowable size&#39;)

            if len(self.lengtharray) == 2:
                self.length = struct.unpack_from(&#39;!H&#39;, self.lengtharray)[0]

                if self.hasmask is True:
                    self.maskarray = bytearray()
                    self.state = MASK
                else:
                    # if there is no mask and no payload we are done
                    if self.length &lt;= 0:
                        try:
                            self._handlePacket()
                        finally:
                            self.state = HEADERB1
                            self.data = bytearray()

                    # we have no mask and some payload
                    else:
                        self.data = bytearray()
                        self.state = PAYLOAD

        elif self.state == LENGTHLONG:

            self.lengtharray.append(byte)

            if len(self.lengtharray) &gt; 8:
                raise Exception(&#39;long length exceeded allowable size&#39;)

            if len(self.lengtharray) == 8:
                self.length = struct.unpack_from(&#39;!Q&#39;, self.lengtharray)[0]

                if self.hasmask is True:
                    self.maskarray = bytearray()
                    self.state = MASK
                else:
                    # if there is no mask and no payload we are done
                    if self.length &lt;= 0:
                        try:
                            self._handlePacket()
                        finally:
                            self.state = HEADERB1
                            self.data = bytearray()

                    # we have no mask and some payload
                    else:
                        self.data = bytearray()
                        self.state = PAYLOAD

        # MASK STATE
        elif self.state == MASK:
            self.maskarray.append(byte)

            if len(self.maskarray) &gt; 4:
                raise Exception(&#39;mask exceeded allowable size&#39;)

            if len(self.maskarray) == 4:
                # if there is no mask and no payload we are done
                if self.length &lt;= 0:
                    try:
                        self._handlePacket()
                    finally:
                        self.state = HEADERB1
                        self.data = bytearray()

                # we have no mask and some payload
                else:
                    self.data = bytearray()
                    self.state = PAYLOAD

        # PAYLOAD STATE
        elif self.state == PAYLOAD:
            if self.hasmask is True:
                self.data.append(byte ^ self.maskarray[self.index % 4])
            else:
                self.data.append(byte)

            # if length exceeds allowable size then we except and remove the
            # connection
            if len(self.data) &gt;= self.maxpayload:
                raise Exception(&#39;payload exceeded allowable size&#39;)

            # check if we have processed length bytes; if so we are done
            if (self.index + 1) == self.length:
                try:
                    self._handlePacket()
                finally:
                    self.state = HEADERB1
                    self.data = bytearray()
            else:
                self.index += 1


class SimpleWebSocketServer(object):
    def __init__(
            self, host, port, websocketclass, selectInterval=0.1, **kwargs):
        self.websocketclass = websocketclass
        self.websock_kwargs = kwargs
        self.serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.serversocket.bind((host, port))
        self.serversocket.listen(5)
        self.selectInterval = selectInterval
        self.connections = {}
        self.listeners = [self.serversocket]

    def _decorateSocket(self, sock):
        return sock

    def _constructWebSocket(self, sock, address):
        return self.websocketclass(self, sock, address, **self.websock_kwargs)

    def close(self):
        self.serversocket.close()

        for desc, conn in self.connections.items():
            conn.close()
            conn.handleClose()

    def _kill_client(self, client, client_id, exception=True):
        del self.connections[id]
        self.listeners.remove(id)
        client.client.close()
        client.handleClose()

        if exception:
            import traceback
            traceback.print_exc()

    def serveforever(self):
        while True:
            writers = []
            for fileno in self.listeners:
                if fileno == self.serversocket:
                    continue
                client = self.connections[fileno]
                if client.sendq:
                    writers.append(fileno)

            if self.selectInterval:
                rList, wList, xList = select(
                    self.listeners, writers,
                    self.listeners, self.selectInterval)
            else:
                rList, wList, xList = select(
                    self.listeners, writers, self.listeners)

            for ready in wList:
                client = self.connections[ready]
                try:
                    while client.sendq:
                        opcode, payload = client.sendq.popleft()
                        remaining = client._sendBuffer(payload)
                        if remaining is not None:
                            client.sendq.appendleft((opcode, remaining))
                            break
                        else:
                            if opcode == CLOSE:
                                raise Exception(&#39;received client close&#39;)

                except Exception:
                    self._kill_client(client, ready)

            for ready in rList:
                if ready == self.serversocket:
                    try:
                        sock, address = self.serversocket.accept()
                        newsock = self._decorateSocket(sock)
                        newsock.setblocking(0)
                        fileno = newsock.fileno()
                        self.connections[fileno] = self._constructWebSocket(
                            newsock, address)
                        self.listeners.append(fileno)
                    except Exception:
                        if sock is not None:
                            sock.close()
                else:
                    if ready not in self.connections:
                        continue
                    client = self.connections[ready]
                    try:
                        client._handleData()
                    except Exception:
                        self._kill_client(client, ready)

            for failed in xList:
                if failed == self.serversocket:
                    self.close()
                    raise Exception(&#39;server socket failed&#39;)
                if failed in self.connections:
                    self._kill_client(self.connections[failed], failed, False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.SimpleWebSocketServer"><code class="flex name class">
<span>class <span class="ident">SimpleWebSocketServer</span></span>
<span>(</span><span>host, port, websocketclass, selectInterval=0.1, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleWebSocketServer(object):
    def __init__(
            self, host, port, websocketclass, selectInterval=0.1, **kwargs):
        self.websocketclass = websocketclass
        self.websock_kwargs = kwargs
        self.serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.serversocket.bind((host, port))
        self.serversocket.listen(5)
        self.selectInterval = selectInterval
        self.connections = {}
        self.listeners = [self.serversocket]

    def _decorateSocket(self, sock):
        return sock

    def _constructWebSocket(self, sock, address):
        return self.websocketclass(self, sock, address, **self.websock_kwargs)

    def close(self):
        self.serversocket.close()

        for desc, conn in self.connections.items():
            conn.close()
            conn.handleClose()

    def _kill_client(self, client, client_id, exception=True):
        del self.connections[id]
        self.listeners.remove(id)
        client.client.close()
        client.handleClose()

        if exception:
            import traceback
            traceback.print_exc()

    def serveforever(self):
        while True:
            writers = []
            for fileno in self.listeners:
                if fileno == self.serversocket:
                    continue
                client = self.connections[fileno]
                if client.sendq:
                    writers.append(fileno)

            if self.selectInterval:
                rList, wList, xList = select(
                    self.listeners, writers,
                    self.listeners, self.selectInterval)
            else:
                rList, wList, xList = select(
                    self.listeners, writers, self.listeners)

            for ready in wList:
                client = self.connections[ready]
                try:
                    while client.sendq:
                        opcode, payload = client.sendq.popleft()
                        remaining = client._sendBuffer(payload)
                        if remaining is not None:
                            client.sendq.appendleft((opcode, remaining))
                            break
                        else:
                            if opcode == CLOSE:
                                raise Exception(&#39;received client close&#39;)

                except Exception:
                    self._kill_client(client, ready)

            for ready in rList:
                if ready == self.serversocket:
                    try:
                        sock, address = self.serversocket.accept()
                        newsock = self._decorateSocket(sock)
                        newsock.setblocking(0)
                        fileno = newsock.fileno()
                        self.connections[fileno] = self._constructWebSocket(
                            newsock, address)
                        self.listeners.append(fileno)
                    except Exception:
                        if sock is not None:
                            sock.close()
                else:
                    if ready not in self.connections:
                        continue
                    client = self.connections[ready]
                    try:
                        client._handleData()
                    except Exception:
                        self._kill_client(client, ready)

            for failed in xList:
                if failed == self.serversocket:
                    self.close()
                    raise Exception(&#39;server socket failed&#39;)
                if failed in self.connections:
                    self._kill_client(self.connections[failed], failed, False)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.SimpleWebSocketServer.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self.serversocket.close()

    for desc, conn in self.connections.items():
        conn.close()
        conn.handleClose()</code></pre>
</details>
</dd>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.SimpleWebSocketServer.serveforever"><code class="name flex">
<span>def <span class="ident">serveforever</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serveforever(self):
    while True:
        writers = []
        for fileno in self.listeners:
            if fileno == self.serversocket:
                continue
            client = self.connections[fileno]
            if client.sendq:
                writers.append(fileno)

        if self.selectInterval:
            rList, wList, xList = select(
                self.listeners, writers,
                self.listeners, self.selectInterval)
        else:
            rList, wList, xList = select(
                self.listeners, writers, self.listeners)

        for ready in wList:
            client = self.connections[ready]
            try:
                while client.sendq:
                    opcode, payload = client.sendq.popleft()
                    remaining = client._sendBuffer(payload)
                    if remaining is not None:
                        client.sendq.appendleft((opcode, remaining))
                        break
                    else:
                        if opcode == CLOSE:
                            raise Exception(&#39;received client close&#39;)

            except Exception:
                self._kill_client(client, ready)

        for ready in rList:
            if ready == self.serversocket:
                try:
                    sock, address = self.serversocket.accept()
                    newsock = self._decorateSocket(sock)
                    newsock.setblocking(0)
                    fileno = newsock.fileno()
                    self.connections[fileno] = self._constructWebSocket(
                        newsock, address)
                    self.listeners.append(fileno)
                except Exception:
                    if sock is not None:
                        sock.close()
            else:
                if ready not in self.connections:
                    continue
                client = self.connections[ready]
                try:
                    client._handleData()
                except Exception:
                    self._kill_client(client, ready)

        for failed in xList:
            if failed == self.serversocket:
                self.close()
                raise Exception(&#39;server socket failed&#39;)
            if failed in self.connections:
                self._kill_client(self.connections[failed], failed, False)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket"><code class="flex name class">
<span>class <span class="ident">WebSocket</span></span>
<span>(</span><span>server, sock, address)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WebSocket(object):

    def __init__(self, server, sock, address):
        self.server = server
        self.client = sock
        self.address = address

        self.handshaked = False
        self.headerbuffer = bytearray()
        self.headertoread = 2048

        self.fin = 0
        self.data = bytearray()
        self.opcode = 0
        self.hasmask = 0
        self.maskarray = None
        self.length = 0
        self.lengtharray = None
        self.index = 0
        self.request = None
        self.usingssl = False

        self.frag_start = False
        self.frag_type = BINARY
        self.frag_buffer = None
        self.frag_decoder = codecs.getincrementaldecoder(
            &#39;utf-8&#39;)(errors=&#39;strict&#39;)
        self.closed = False
        self.sendq = deque()

        self.state = HEADERB1

        # restrict the size of header and payload for security reasons
        self.maxheader = MAXHEADER
        self.maxpayload = MAXPAYLOAD

    def handleMessage(self):
        &#34;&#34;&#34;
            Called when websocket frame is received.
            To access the frame data call self.data.

            If the frame is Text then self.data is a unicode object.
            If the frame is Binary then self.data is a bytearray object.
        &#34;&#34;&#34;
        pass

    def handleConnected(self):
        &#34;&#34;&#34;
            Called when a websocket client connects to the server.
        &#34;&#34;&#34;
        pass

    def handleClose(self):
        &#34;&#34;&#34;
            Called when a websocket server gets a Close frame from a client.
        &#34;&#34;&#34;
        pass

    def _handlePacket(self):
        if self.opcode == CLOSE:
            pass
        elif self.opcode == STREAM:
            pass
        elif self.opcode == TEXT:
            pass
        elif self.opcode == BINARY:
            pass
        elif self.opcode == PONG or self.opcode == PING:
            if len(self.data) &gt; 125:
                raise Exception(&#39;control frame length can not be &gt; 125&#39;)
        else:
            # unknown or reserved opcode so just close
            raise Exception(&#39;unknown opcode&#39;)

        if self.opcode == CLOSE:
            status = 1000
            reason = u&#39;&#39;
            length = len(self.data)

            if length == 0:
                pass
            elif length &gt;= 2:
                status = struct.unpack_from(&#39;!H&#39;, self.data[:2])[0]
                reason = self.data[2:]

                if status not in _VALID_STATUS_CODES:
                    status = 1002

                if len(reason) &gt; 0:
                    try:
                        reason = reason.decode(&#39;utf8&#39;, errors=&#39;strict&#39;)
                    except:
                        status = 1002
            else:
                status = 1002

            self.close(status, reason)
            return

        elif self.fin == 0:
            if self.opcode != STREAM:
                if self.opcode == PING or self.opcode == PONG:
                    raise Exception(&#39;control messages can not be fragmented&#39;)

                self.frag_type = self.opcode
                self.frag_start = True
                self.frag_decoder.reset()

                if self.frag_type == TEXT:
                    self.frag_buffer = []
                    utf_str = self.frag_decoder.decode(self.data, final=False)
                    if utf_str:
                        self.frag_buffer.append(utf_str)
                else:
                    self.frag_buffer = bytearray()
                    self.frag_buffer.extend(self.data)

            else:
                if self.frag_start is False:
                    raise Exception(&#39;fragmentation protocol error&#39;)

                if self.frag_type == TEXT:
                    utf_str = self.frag_decoder.decode(self.data, final=False)
                    if utf_str:
                        self.frag_buffer.append(utf_str)
                else:
                    self.frag_buffer.extend(self.data)

        else:
            if self.opcode == STREAM:
                if self.frag_start is False:
                    raise Exception(&#39;fragmentation protocol error&#39;)

                if self.frag_type == TEXT:
                    utf_str = self.frag_decoder.decode(self.data, final=True)
                    self.frag_buffer.append(utf_str)
                    self.data = u&#39;&#39;.join(self.frag_buffer)
                else:
                    self.frag_buffer.extend(self.data)
                    self.data = self.frag_buffer

                self.handleMessage()

                self.frag_decoder.reset()
                self.frag_type = BINARY
                self.frag_start = False
                self.frag_buffer = None

            elif self.opcode == PING:
                self._sendMessage(False, PONG, self.data)

            elif self.opcode == PONG:
                pass

            else:
                if self.frag_start is True:
                    raise Exception(&#39;fragmentation protocol error&#39;)

                if self.opcode == TEXT:
                    try:
                        self.data = self.data.decode(&#39;utf8&#39;, errors=&#39;strict&#39;)
                    except Exception:
                        raise Exception(&#39;invalid utf-8 payload&#39;)

                self.handleMessage()

    def _handleData(self):
        # do the HTTP header and handshake
        if self.handshaked is False:

            data = self.client.recv(self.headertoread)
            if not data:
                raise Exception(&#39;remote socket closed&#39;)

            else:
                # accumulate
                self.headerbuffer.extend(data)

                if len(self.headerbuffer) &gt;= self.maxheader:
                    raise Exception(&#39;header exceeded allowable size&#39;)

                # indicates end of HTTP header
                if b&#39;\r\n\r\n&#39; in self.headerbuffer:
                    self.request = HTTPRequest(self.headerbuffer)

                    # handshake rfc 6455
                    try:
                        key = self.request.headers[&#39;Sec-WebSocket-Key&#39;]
                        k = key.encode(&#39;ascii&#39;) + GUID_STR.encode(&#39;ascii&#39;)
                        k_s = base64.b64encode(
                            hashlib.sha1(k).digest()).decode(&#39;ascii&#39;)
                        hStr = HANDSHAKE_STR % {&#39;acceptstr&#39;: k_s}
                        self.sendq.append((BINARY, hStr.encode(&#39;ascii&#39;)))
                        self.handshaked = True
                        self.handleConnected()
                    except Exception as e:
                        raise Exception(&#39;handshake failed: %s&#39;, str(e))

        # else do normal data
        else:
            data = self.client.recv(8192)
            if not data:
                raise Exception(&#34;remote socket closed&#34;)

            if VER &gt;= 3:
                for d in data:
                    self._parseMessage(d)
            else:
                for d in data:
                    self._parseMessage(ord(d))

    def close(self, status=1000, reason=u&#39;&#39;):
        &#34;&#34;&#34;
           Send Close frame to the client. The underlying socket is only closed
           when the client acknowledges the Close frame.

           status is the closing identifier.
           reason is the reason for the close.
         &#34;&#34;&#34;
        try:
            if self.closed is False:
                close_msg = bytearray()
                close_msg.extend(struct.pack(&#34;!H&#34;, status))
                if _check_unicode(reason):
                    close_msg.extend(reason.encode(&#39;utf-8&#39;))
                else:
                    close_msg.extend(reason)

                self._sendMessage(False, CLOSE, close_msg)

        finally:
            self.closed = True

    def _sendBuffer(self, buff):
        size = len(buff)
        tosend = size
        already_sent = 0

        while tosend &gt; 0:
            try:
                # i should be able to send a bytearray
                sent = self.client.send(buff[already_sent:])
                if sent == 0:
                    raise RuntimeError(&#39;socket connection broken&#39;)

                already_sent += sent
                tosend -= sent

            except socket.error as e:
                # if we have full buffers then wait for them to drain and try
                # again
                if e.errno in [errno.EAGAIN, errno.EWOULDBLOCK]:
                    return buff[already_sent:]
                else:
                    raise e

        return None

    def sendFragmentStart(self, data):
        &#34;&#34;&#34;
            Send the start of a data fragment stream to a websocket client.
            Subsequent data should be sent using sendFragment().
            A fragment stream is completed when sendFragmentEnd() is called.

            If data is a unicode object then the frame is sent as Text.
            If the data is a bytearray object then the frame is sent as Binary.
        &#34;&#34;&#34;
        opcode = BINARY
        if _check_unicode(data):
            opcode = TEXT
        self._sendMessage(True, opcode, data)

    def sendFragment(self, data):
        &#34;&#34;&#34;
            see sendFragmentStart()

            If data is a unicode object then the frame is sent as Text.
            If the data is a bytearray object then the frame is sent as Binary.
        &#34;&#34;&#34;
        self._sendMessage(True, STREAM, data)

    def sendFragmentEnd(self, data):
        &#34;&#34;&#34;
            see sendFragmentEnd()

            If data is a unicode object then the frame is sent as Text.
            If the data is a bytearray object then the frame is sent as Binary.
        &#34;&#34;&#34;
        self._sendMessage(False, STREAM, data)

    def sendMessage(self, data):
        &#34;&#34;&#34;
            Send websocket data frame to the client.

            If data is a unicode object then the frame is sent as Text.
            If the data is a bytearray object then the frame is sent as Binary.
        &#34;&#34;&#34;
        opcode = BINARY
        if _check_unicode(data):
            opcode = TEXT
        self._sendMessage(False, opcode, data)

    def _sendMessage(self, fin, opcode, data):

        payload = bytearray()

        b1 = 0
        b2 = 0
        if fin is False:
            b1 |= 0x80
        b1 |= opcode

        if _check_unicode(data):
            data = data.encode(&#39;utf-8&#39;)

        length = len(data)
        payload.append(b1)

        if length &lt;= 125:
            b2 |= length
            payload.append(b2)

        elif length &gt;= 126 and length &lt;= 65535:
            b2 |= 126
            payload.append(b2)
            payload.extend(struct.pack(&#34;!H&#34;, length))

        else:
            b2 |= 127
            payload.append(b2)
            payload.extend(struct.pack(&#34;!Q&#34;, length))

        if length &gt; 0:
            payload.extend(data)

        self.sendq.append((opcode, payload))

    def _parseMessage(self, byte):
        # read in the header
        if self.state == HEADERB1:

            self.fin = byte &amp; 0x80
            self.opcode = byte &amp; 0x0F
            self.state = HEADERB2

            self.index = 0
            self.length = 0
            self.lengtharray = bytearray()
            self.data = bytearray()

            rsv = byte &amp; 0x70
            if rsv != 0:
                raise Exception(&#39;RSV bit must be 0&#39;)

        elif self.state == HEADERB2:
            mask = byte &amp; 0x80
            length = byte &amp; 0x7F

            if self.opcode == PING and length &gt; 125:
                raise Exception(&#39;ping packet is too large&#39;)

            if mask == 128:
                self.hasmask = True
            else:
                self.hasmask = False

            if length &lt;= 125:
                self.length = length

                # if we have a mask we must read it
                if self.hasmask is True:
                    self.maskarray = bytearray()
                    self.state = MASK
                else:
                    # if there is no mask and no payload we are done
                    if self.length &lt;= 0:
                        try:
                            self._handlePacket()
                        finally:
                            self.state = self.HEADERB1
                            self.data = bytearray()

                    # we have no mask and some payload
                    else:
                        self.data = bytearray()
                        self.state = PAYLOAD

            elif length == 126:
                self.lengtharray = bytearray()
                self.state = LENGTHSHORT

            elif length == 127:
                self.lengtharray = bytearray()
                self.state = LENGTHLONG

        elif self.state == LENGTHSHORT:
            self.lengtharray.append(byte)

            if len(self.lengtharray) &gt; 2:
                raise Exception(&#39;short length exceeded allowable size&#39;)

            if len(self.lengtharray) == 2:
                self.length = struct.unpack_from(&#39;!H&#39;, self.lengtharray)[0]

                if self.hasmask is True:
                    self.maskarray = bytearray()
                    self.state = MASK
                else:
                    # if there is no mask and no payload we are done
                    if self.length &lt;= 0:
                        try:
                            self._handlePacket()
                        finally:
                            self.state = HEADERB1
                            self.data = bytearray()

                    # we have no mask and some payload
                    else:
                        self.data = bytearray()
                        self.state = PAYLOAD

        elif self.state == LENGTHLONG:

            self.lengtharray.append(byte)

            if len(self.lengtharray) &gt; 8:
                raise Exception(&#39;long length exceeded allowable size&#39;)

            if len(self.lengtharray) == 8:
                self.length = struct.unpack_from(&#39;!Q&#39;, self.lengtharray)[0]

                if self.hasmask is True:
                    self.maskarray = bytearray()
                    self.state = MASK
                else:
                    # if there is no mask and no payload we are done
                    if self.length &lt;= 0:
                        try:
                            self._handlePacket()
                        finally:
                            self.state = HEADERB1
                            self.data = bytearray()

                    # we have no mask and some payload
                    else:
                        self.data = bytearray()
                        self.state = PAYLOAD

        # MASK STATE
        elif self.state == MASK:
            self.maskarray.append(byte)

            if len(self.maskarray) &gt; 4:
                raise Exception(&#39;mask exceeded allowable size&#39;)

            if len(self.maskarray) == 4:
                # if there is no mask and no payload we are done
                if self.length &lt;= 0:
                    try:
                        self._handlePacket()
                    finally:
                        self.state = HEADERB1
                        self.data = bytearray()

                # we have no mask and some payload
                else:
                    self.data = bytearray()
                    self.state = PAYLOAD

        # PAYLOAD STATE
        elif self.state == PAYLOAD:
            if self.hasmask is True:
                self.data.append(byte ^ self.maskarray[self.index % 4])
            else:
                self.data.append(byte)

            # if length exceeds allowable size then we except and remove the
            # connection
            if len(self.data) &gt;= self.maxpayload:
                raise Exception(&#39;payload exceeded allowable size&#39;)

            # check if we have processed length bytes; if so we are done
            if (self.index + 1) == self.length:
                try:
                    self._handlePacket()
                finally:
                    self.state = HEADERB1
                    self.data = bytearray()
            else:
                self.index += 1</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="spixel.drivers.SimPixel.websocket.Client" href="websocket.html#spixel.drivers.SimPixel.websocket.Client">Client</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, status=1000, reason='')</span>
</code></dt>
<dd>
<section class="desc"><p>Send Close frame to the client. The underlying socket is only closed
when the client acknowledges the Close frame.</p>
<p>status is the closing identifier.
reason is the reason for the close.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, status=1000, reason=u&#39;&#39;):
    &#34;&#34;&#34;
       Send Close frame to the client. The underlying socket is only closed
       when the client acknowledges the Close frame.

       status is the closing identifier.
       reason is the reason for the close.
     &#34;&#34;&#34;
    try:
        if self.closed is False:
            close_msg = bytearray()
            close_msg.extend(struct.pack(&#34;!H&#34;, status))
            if _check_unicode(reason):
                close_msg.extend(reason.encode(&#39;utf-8&#39;))
            else:
                close_msg.extend(reason)

            self._sendMessage(False, CLOSE, close_msg)

    finally:
        self.closed = True</code></pre>
</details>
</dd>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.handleClose"><code class="name flex">
<span>def <span class="ident">handleClose</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when a websocket server gets a Close frame from a client.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handleClose(self):
    &#34;&#34;&#34;
        Called when a websocket server gets a Close frame from a client.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.handleConnected"><code class="name flex">
<span>def <span class="ident">handleConnected</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when a websocket client connects to the server.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handleConnected(self):
    &#34;&#34;&#34;
        Called when a websocket client connects to the server.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.handleMessage"><code class="name flex">
<span>def <span class="ident">handleMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when websocket frame is received.
To access the frame data call self.data.</p>
<p>If the frame is Text then self.data is a unicode object.
If the frame is Binary then self.data is a bytearray object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handleMessage(self):
    &#34;&#34;&#34;
        Called when websocket frame is received.
        To access the frame data call self.data.

        If the frame is Text then self.data is a unicode object.
        If the frame is Binary then self.data is a bytearray object.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendFragment"><code class="name flex">
<span>def <span class="ident">sendFragment</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>see sendFragmentStart()</p>
<p>If data is a unicode object then the frame is sent as Text.
If the data is a bytearray object then the frame is sent as Binary.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendFragment(self, data):
    &#34;&#34;&#34;
        see sendFragmentStart()

        If data is a unicode object then the frame is sent as Text.
        If the data is a bytearray object then the frame is sent as Binary.
    &#34;&#34;&#34;
    self._sendMessage(True, STREAM, data)</code></pre>
</details>
</dd>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendFragmentEnd"><code class="name flex">
<span>def <span class="ident">sendFragmentEnd</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>see sendFragmentEnd()</p>
<p>If data is a unicode object then the frame is sent as Text.
If the data is a bytearray object then the frame is sent as Binary.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendFragmentEnd(self, data):
    &#34;&#34;&#34;
        see sendFragmentEnd()

        If data is a unicode object then the frame is sent as Text.
        If the data is a bytearray object then the frame is sent as Binary.
    &#34;&#34;&#34;
    self._sendMessage(False, STREAM, data)</code></pre>
</details>
</dd>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendFragmentStart"><code class="name flex">
<span>def <span class="ident">sendFragmentStart</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Send the start of a data fragment stream to a websocket client.
Subsequent data should be sent using sendFragment().
A fragment stream is completed when sendFragmentEnd() is called.</p>
<p>If data is a unicode object then the frame is sent as Text.
If the data is a bytearray object then the frame is sent as Binary.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendFragmentStart(self, data):
    &#34;&#34;&#34;
        Send the start of a data fragment stream to a websocket client.
        Subsequent data should be sent using sendFragment().
        A fragment stream is completed when sendFragmentEnd() is called.

        If data is a unicode object then the frame is sent as Text.
        If the data is a bytearray object then the frame is sent as Binary.
    &#34;&#34;&#34;
    opcode = BINARY
    if _check_unicode(data):
        opcode = TEXT
    self._sendMessage(True, opcode, data)</code></pre>
</details>
</dd>
<dt id="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendMessage"><code class="name flex">
<span>def <span class="ident">sendMessage</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Send websocket data frame to the client.</p>
<p>If data is a unicode object then the frame is sent as Text.
If the data is a bytearray object then the frame is sent as Binary.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendMessage(self, data):
    &#34;&#34;&#34;
        Send websocket data frame to the client.

        If data is a unicode object then the frame is sent as Text.
        If the data is a bytearray object then the frame is sent as Binary.
    &#34;&#34;&#34;
    opcode = BINARY
    if _check_unicode(data):
        opcode = TEXT
    self._sendMessage(False, opcode, data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spixel.drivers.SimPixel" href="index.html">spixel.drivers.SimPixel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.SimpleWebSocketServer" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.SimpleWebSocketServer">SimpleWebSocketServer</a></code></h4>
<ul class="">
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.SimpleWebSocketServer.close" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.SimpleWebSocketServer.close">close</a></code></li>
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.SimpleWebSocketServer.serveforever" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.SimpleWebSocketServer.serveforever">serveforever</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket">WebSocket</a></code></h4>
<ul class="two-column">
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.close" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.close">close</a></code></li>
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.handleClose" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.handleClose">handleClose</a></code></li>
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.handleConnected" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.handleConnected">handleConnected</a></code></li>
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.handleMessage" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.handleMessage">handleMessage</a></code></li>
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendFragment" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendFragment">sendFragment</a></code></li>
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendFragmentEnd" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendFragmentEnd">sendFragmentEnd</a></code></li>
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendFragmentStart" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendFragmentStart">sendFragmentStart</a></code></li>
<li><code><a title="spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendMessage" href="#spixel.drivers.SimPixel.SimpleWebSocketServer.WebSocket.sendMessage">sendMessage</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>